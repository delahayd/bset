# bset.zf

val tup : type -> type -> type.
val set : type -> type.
val mem : pi (a : type). a -> set a -> prop.
val pair : pi (a b : type).a -> b -> (tup a b).
val power : pi (a : type). set a -> set (set a).
val subset : pi (a : type). set a -> set a -> prop.
val times : pi (a b : type). set a -> set b -> set (tup a b).
val union : pi (a : type). set a -> set a -> set a.
val inter : pi (a : type). set a -> set a -> set a.
val diff : pi (a : type). set a -> set a -> set a.
val empty: pi (a : type). set a.
val plmngt : pi (a b : type). set a -> set b -> set (set (tup a b)).
val mnmngt : pi (a b : type). set a -> set b -> set (set (tup a b)).
val relation: pi (a b : type). set a -> set b -> set (set (tup a b)).
val dom : pi (a b : type). set (tup a b) -> set a.
val ran: pi (a b: type). set(tup a b) -> set b.
val inverse : pi (a b : type). set (tup a b) -> set (tup b a).
val tup21 : pi (a b : type). b -> a -> tup b a.
val semicolon : pi (a b c : type). set (tup a b) -> set (tup b c) -> set (tup a c).
val image : pi (a b : type). set (tup a b) -> set a -> set b.
val id : pi (a : type). set a -> set (tup a a).
val domain_restriction : pi (a b : type). set a -> set (tup a b) -> set (tup a b).
val range_restriction : pi (a b : type). set (tup a b) -> set b -> set (tup a b).
val domain_substraction : pi (a b : type). set a -> set (tup a b) -> set (tup a b).
val range_substraction : pi (a b : type). set (tup a b) -> set b -> set (tup a b).
val lspl : pi (a b : type). set (tup a b) -> set (tup a b) -> set (tup a b).
val direct_product : pi (a b c : type). set (tup a b) -> set (tup a c) -> set (tup a (tup b c)).
val parallel_product : pi (a b c d : type). set (tup a b) ->  set (tup c d) -> set (tup (tup a c) (tup b d)).
val singleton : pi (a : type). a -> set a.
val plmngtgt : pi (a b : type). set a -> set b -> set (set (tup a b)).
val gtmngtgt : pi (a b : type). set a -> set b -> set (set (tup a b)).
val gtmngt : pi (a b : type). set a -> set b -> set (set(tup a b)).
val mnmngtgt : pi (a b : type). set a -> set b -> set (set(tup a b)).
val gtplgt : pi (a b : type). set a -> set b -> set (set(tup a b)).
val prj1 : pi (a b : type). tup (set a) (set b) -> set (tup (tup a b) a).
val prj2 : pi (a b : type). tup (set a) (set b) -> set (tup (tup a b) b).

val fst : pi (a b : type). tup a b -> a.
val snd : pi (a b : type). tup a b -> b.

rewrite forall (a b : type) (x:a)(y:b). fst (pair _ _ x y) = x.
rewrite forall (a b : type) (x:a)(y:b). snd (pair _ _ x y) = y.

#tup21 --> pair
#rewrite
#  forall (a b : type) (x : a) (y : b). (tup21 a b y x) = (pair b a y x).

#rewrite
#  forall (a b : type) (z : tup a b) (S : set a) (T : set b).
#    mem (tup a b) z (times a b S T) <=>
#      (exists (x : a) (y : b). z = (pair a b x y) && mem a x S && mem b y T).

rewrite
  forall (a : type) (b : type) (x : a) (y : b) (S : set a) (T : set b).
    mem (tup a b) (pair a b x y) (times a b S T) <=> mem a x S && mem b y T.

rewrite
  forall (a b : type) (z : tup a b) (S1 : set a) (S2 : set b).
    mem (tup a b) z (times _ _ S1 S2) <=>
      mem a (fst _ _ z) S1 && mem b (snd _ _ z) S2.

rewrite
  forall (a : type) (S T : set a).
    mem (set a) S (power a T) <=> (forall (x : a). (mem a x S) => (mem a x T)).

rewrite
  forall (a : type) (S T : set a). subset a S T <=> mem (set a) S (power a T).

# Extensional equality
rewrite
  forall (a : type) (S T : set a).
    S = T <=> (forall (x : a). (mem a x S) <=> (mem a x T)).

# Equality over tuples
rewrite
  forall (a b : type) (x y : tup a b).
    x = y <=> (fst a b x) = (fst a b y) && (snd a b x) = (snd a b y). 

rewrite
  forall (a : type) (x : a) (S T : set a).
    mem a x (union a S T) <=> mem a x S || mem a x T.

rewrite
  forall (a : type) (x : a) (S T : set a).
    mem a x (inter a S T) <=> mem a x S && mem a x T.
#diff
rewrite
  forall (a : type) (x : a) (S T : set a).
    mem a x (diff a S T) <=> mem a x S && ~ (mem a x T).

rewrite
  forall (a b : type) (x x1 : a) (y y1 : b).
    pair a b x y = pair a b x1 y1 <=> x = x1 && y = y1.

#empty
rewrite
  forall (a : type) (x : a).
    mem a x (empty a) <=> false.

#+-> PLusMiNusGreaTer plmngt mem_partial_function_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (F : set (tup a b)).
    mem (set (tup a b)) F (plmngt a b S T) <=> mem (set (tup a b)) F (relation a b S T) && (forall (X : a) (Y1 Y2 : b). mem (tup a b) (pair X Y1) F && (mem (tup a b) (pair X Y2) F) => (Y1 = Y2)).
    
#--> MiNusMiNusGreaTer mnmngt mem_total_function_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set(tup a b)) X (mnmngt a b S T) <=> mem (set(tup a b)) X (plmngt a b S T) && (dom a b X) = S.


#ran
rewrite
  forall (a b : type) (P : set (tup a b)) (X : b).
    mem b X (ran a b P) <=> (exists (A1 : a). mem (tup a b) (tup21 b a A1 X) P).

#dom
rewrite
  forall (a b : type) (P : set (tup a b)) (X: a).
    mem a X (dom a b P) <=> (exists (B1 : b). mem (tup a b) (tup21 b a X B1) P).

#inverse
rewrite
  forall (a b : type) (P : set (tup a b)) (X : b) (Y : a).
    mem (tup b a) (tup21 a b X Y) (inverse a b P) <=> mem (tup a b) (tup21 b a Y X) P.

#relation
rewrite
   forall (a b : type) (U : set a) (V : set b) (R: set (tup a b)).
     mem (set (tup a b)) R (relation a b U V) <=> (forall (X : a) (Y : b). mem (tup a b) (tup21 b a X Y) R => mem a X U && mem b Y V).

#semicolon
rewrite
  forall (a b c : type) (P : set (tup a b)) (Q : set (tup b c)) (X : a) (Y : c).
    mem (tup a c) (tup21 c a X Y) (semicolon a b c P Q) <=> (exists (B1 : b). mem (tup a b) (tup21 b a X B1) P && mem (tup b c) (tup21 c b B1 Y) Q).

#image
rewrite
  forall (a b : type) (P : set (tup a b)) (W : set a) (X : b).
    mem b X (image a b P W) <=> (exists (A1 : a). mem a A1 W && mem (tup a b) (tup21 b a A1 X) P).

#id
#rewrite
#  forall (a : type) (U : set a) (X : a) (Y : a).
#    mem (tup a a) (tup21 a a X Y) (id a U) <=> mem a X U && X = Y.

#rewrite
#  forall (a : type) (U : set a) (X : a) (Y : a).
#    mem (tup a a) (pair a a X Y) (id a U) <=> mem a X U && X = Y.

rewrite
  forall (a : type) (U : set a) (z : tup a a).
    mem (tup a a) z (id a U) <=> mem a (fst a a z) U && (fst a a z) = (snd a a z).

#domain_restriction
rewrite
  forall (a b : type) (P: set (tup a b)) (S : set a) (X : a) (Y : b).
    mem (tup a b) (tup21 b a X Y) (domain_restriction a b S P) <=> mem (tup a b) (tup21 b a X Y) P && mem a X S.

#range_restriction
rewrite
  forall (a b : type) (P : set (tup a b)) (T : set b) (X : a) (Y : b).
    mem (tup a b) (tup21 b a X Y) (range_restriction a b P T) <=> mem (tup a b) (tup21 b a X Y) P && mem b Y T.

#domain_substraction
rewrite
  forall (a b : type) (P : set (tup a b)) (S : set a) (X : a) (Y : b).
    mem (tup a b) (tup21 b a X Y) (domain_substraction a b S P) <=> mem (tup a b) (tup21 b a X Y) P && ~ (mem a X S).

#range_substraction
rewrite
  forall (a b : type) (P : set (tup a b)) (T: set b) (X : a) (Y: b).
    mem (tup a b) (tup21 b a X Y) (range_substraction a b P T) <=> mem (tup a b) (tup21 b a X Y) P && ~ (mem b Y T).

#lspl mem_overriding
rewrite
  forall (a b : type) (P Q : set (tup a b)) (X : a) (Y : b).
    mem (tup a b) (tup21 b a X Y) (lspl a b Q P) <=> mem (tup a b) (tup21 b a X Y) Q && ~ mem a X (dom a b P) || mem (tup a b) (tup21 b a X Y) P.

#direct_product
rewrite
  forall (a b c : type) (F : set (tup a b)) (G : set (tup a c)) (X : a) (Y : b) (Z : c).
    mem (tup a (tup b c)) (tup21 (tup b c) a X (tup21 c b Y Z)) (direct_product a b c F G) <=> mem (tup a b) (tup21 b a X Y) F && mem (tup a c) (tup21 c a X Z) G.

#parallel_product
rewrite
  forall (a b c d : type) (H : set (tup a b)) (K : set (tup c d)) (X : a) (Y: c) (Z : b) (W : d).
    mem (tup (tup a c) (tup b d)) (tup21 (tup b d) (tup a c) (tup21 c a X Y) (tup21 d b Z W)) (parallel_product a b c d H K) <=> mem (tup a b) (tup21 b a X Z) H && mem (tup c d) (tup21 d c Y W) K.

#singleton
rewrite
  forall (a : type) (X Y : a).
    mem a X (singleton a Y) <=> X = Y.

#plmngtgt mem_partial_surjection_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set (tup a b)) X (plmngtgt a b S T) <=> mem (set (tup a b)) X (plmngt a b S T) && ran a b X = T.

#gtmngtgt mem_total_bijection_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set (tup a b)) X (gtmngtgt a b S T) <=> mem (set (tup a b)) X (gtmngt a b S T) && mem (set (tup a b)) X (mnmngtgt a b S T).

#gtmngt mem_total_injection_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set (tup a b)) X (gtmngt a b S T) <=> mem (set (tup a b)) X (gtplgt a b S T) && mem (set (tup a b)) X (mnmngt a b S T).

#mnmngtgt mem_total_surjection_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set (tup a b)) X (mnmngtgt a b S T) <=> mem (set (tup a b)) X (plmngtgt a b S T) && mem (set (tup a b)) X (mnmngt a b S T).

#gtplgt mem_partial_injection_set
rewrite
  forall (a b : type) (S : set a) (T : set b) (X : set (tup a b)).
    mem (set (tup a b)) X (gtplgt a b S T) <=> mem (set (tup a b)) X (plmngt a b S T) && mem (set (tup b a)) (inverse a b X) (plmngt b a T S).

#prj1
rewrite
  forall (a b : type) (S : set a) (T : set b) (x z : a) (y : b).
   mem (tup (tup a b) a) (pair (tup a b) a (pair a b x y) z) (prj1 a b (pair (set a) (set b) S T)) <=> mem (tup (tup a b) a) (pair (tup a b) a (pair a b x y) z) (times (tup a b) a (times a b S T) S) && z = x.

#prj2
rewrite
  forall (a b : type) (S : set a) (T : set b) (x : a) (y z : b).
   mem (tup (tup a b) b) (pair (tup a b) b (pair a b x y) z) (prj2 a b (pair (set a) (set b) S T)) <=> mem (tup (tup a b) b) (pair (tup a b) b (pair a b x y) z) (times (tup a b) b (times a b S T) T) && z = y.